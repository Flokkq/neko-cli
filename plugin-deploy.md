Neko CLI - will be plugin based in the future
To set up Neko CLI you will need to run `neko install {plugin}`

The default installation features only Repository Information Commands.

Plugins at start:
- Neko Release
- Neko Deploy

# Neko Deploy

Neko deploy will be a fully declarative infrastructure deployment plugin for Neko-cli.
In the beginning it focuses on bare metal deployments via SSH. Eventually in the feature Kubernetes based deployments via helm.

Unlike Ansible or Terraform, Neko Deploy is:
- infrastructure-specific
- state-driven
- history-aware
- implemented in a general-purpose language (Go)

## Core Principles

### Declarative Desired State
Users describe what should exist, not how to create it.

### State Awareness
- Every successful deployment produces a persisted state snapshot.
- Future deployments are diffs between desired state and last known state.

### Idempotency
Re-running the same deployment must not change the system.

### Rollback Safety
Failed deployments rollback to the last known good state.

### SSH-first
- No agents required.
- Works on bare metal and minimal systems.

### Infrastructure Semantics
Components like DBs, DNS, proxies, and regions are first-class concepts.

## Supported Components (Initial Scope)

### Core Infrastructure
- CoreDNS
- HAProxy
- Nginx
- Tailscale

### Common setups
- hostname
- MOTD banners
- shell aliases
- base packages

### Datastores
- Redis
- CockroachDB
- ElasticSearch
- ScyllaDB

### Future / Optional
- Kafka
- ClickHouse
- Kubernetes clusters
- Custom Helm charts
- Custom container images

## High-Level Architecture
```
neko-cli
 └── neko deploy
      ├── planner
      ├── executor (ssh)
      ├── state manager
      ├── rollback engine
      ├── providers
      │    ├── coredns
      │    ├── cockroachdb
      │    └── ...
      └── tui
```

## Directory Structure

Each deployable component has its own directory (Excellent for Infrastructure Repositories):
```
/CoreDNS
 ├── templates
 │    └── template-coredns-v1.json
 └── history
      └── 2026-01-18T10-22-01-coredns-v1.json
```

### Templates
- Generated by the CLI
- Edited by the user
- Represent the desired state

### History
- Generated by Neko Deploy
- Represents the observed state
- Only written on successful deployments
- Used for diffing and rollback

## Template Lifecycle

### 1. Generate template
```bash
neko deploy init coredns
```

### 2. Configure
User edits the generated template

### 3. Plan
```bash
neko deploy plan coredns
```

Compares template against last history state. Outputs intended changes.

### 4. Apply
```bash
neko deploy apply coredns
```

## Deployment Flow (V1)

1. Load desired template
2. Load last successful history state (if any)
3. Compute deployment plan
4. Execute plan via SSH
5. Verify remote state
6. If successful:
    - Write history file
    - Attach commit metadata
7. If failed:
    - Trigger rollback
    - Restore previous state

## History & Deployment Commits

Each successful deployment produces a deployment commit.

This allows:
- full deployment history
- reproducible redeployments
- safe rollbacks

## Rollback Strategy

Rollbacks are state-based, not command-based.

On failure:
- The executor restores the previous observed state.
- No partial deployments are left behind.

Rollbacks must be idempotent and verified.

## Declarative Cross-Component Linking

Neko Deploy understands relationships between components.

**Example:**
```yaml
dns:
  records:
    db1.example.com: cockroachdb-eu-01
```

The tool resolves:
- component name → node → IP
- applies DNS changes automatically

This enables:
- DBs referenced by name
- automatic reconfiguration on scaling
- region-aware deployments

## UI / Observability

A terminal UI (similar to btop) can provide:

- live deployment progress
- current component states
- node health
- deployment history

The TUI is:
- read-only
- driven entirely by state files
- decoupled from deployment logic

## Kubernetes Support (Future)

- Kubernetes deployments are treated as another provider
- Helm charts become templates
- State is still managed by Neko Deploy
- Allows hybrid infra (bare metal + k8s)

## Why Not Ansible / Terraform?

**Ansible** lacks strong state and history.

**Terraform** is resource-centric, not service-centric.

Neko Deploy is optimized for:
- SSH
- DB lifecycles
- infrastructure semantics
- reproducibility

## MVP Scope

V1 should include only:

- 1–2 core components (e.g. CoreDNS + CockroachDB)
- SSH executor
- Template → Plan → Apply
- History + rollback
- No UI

Everything else is layered on top.